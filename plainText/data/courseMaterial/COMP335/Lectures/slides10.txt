



















Languages and Finite Automata


COMP 335
*
NPDA Accept 
Context-Free Languages
*

COMP 335


COMP 335
*
Context-Free
Languages
(Grammars)
Languages
Accepted by
NPDAs
Theorem:

COMP 335



COMP 335
*
Context-Free
Languages
(Grammars)
Languages
Accepted by
NPDAs
Proof - Step 1:
Convert any context-free grammar    
to a NPDA         with: 

COMP 335






COMP 335
*
Context-Free
Languages
(Grammars)
Languages
Accepted by
NPDAs
Proof - Step 2:
Convert any NPDA        to a context-free    
grammar         with: 

COMP 335






COMP 335
*
Converting 
Context-Free Grammars
to 
NPDAs
 

Proof - step 1

COMP 335


COMP 335
*
to an NPDA automaton
We will convert any context-free grammar 
Such that:
Simulates leftmost derivations of 

COMP 335






COMP 335
*
In general:
Given any CFG grammar 
We can construct a NPDA 
With

COMP 335





COMP 335
*
Constructing NPDA       from grammar     :





For any production
For any terminal

COMP 335













COMP 335
*




Input
processed
Stack
contents
Input
Stack
leftmost variable
Leftmost derivation
Simulation of derivation

COMP 335
















COMP 335
*
Grammar
leftmost 
derivation
PDA computation
Simulates grammar 
leftmost derivations
Leftmost
variable

COMP 335
*








COMP 335
*


Input
Stack
Leftmost derivation
Simulation of derivation
string of all terminals
end of input is reached

COMP 335










COMP 335
*
An example grammar G:
What is an equivalent NPDA? That is, 
what is an NDPA M such that L(M)=L(G)?

COMP 335



*





Grammar:
NPDA


*












COMP 335
*
Grammar:
A leftmost derivation:

COMP 335




COMP 335
*





Input

Stack

Time 0
Derivation:

COMP 335














COMP 335
*





Input

Stack


Time 0
Derivation:

COMP 335
















COMP 335
*




Input

Stack



Time 1
Derivation:

COMP 335



















COMP 335
*




Input

Stack



Time 2
Derivation:

COMP 335



















COMP 335
*




Input

Stack



Time 3
Derivation:

COMP 335


















COMP 335
*




Input

Stack



Time 4
Derivation:

COMP 335


















COMP 335
*




Input

Stack



Time 5
Derivation:

COMP 335


















COMP 335
*




Input

Stack



Time 6
Derivation:

COMP 335


















COMP 335
*




Input

Stack



Time 7
Derivation:

COMP 335

















COMP 335
*




Input

Stack



Time 8
Derivation:

COMP 335















COMP 335
*





Input

Stack


accept
Time 9
Derivation:

COMP 335













COMP 335
*
In general:
Given any CFG grammar 
We can construct a NPDA 
With

COMP 335





COMP 335
*
Constructing NPDA       from grammar     :





For any production
For any terminal

COMP 335













COMP 335
*
        
    generates 
           
     accepts         
In general, it can be shown that:
if and
only if
Therefore,

COMP 335
*













COMP 335
*
The CFG grammar      generates 
a string     if and only if the
NPDA         accepts     , i.e.,


COMP 335







COMP 335
*
Therefore:
Given any context-free language  L, 
expressed by a context-free grammar  G,
there exists an NPDA M that accepts L, 
i.e.,  L(M) = L(G) = L.
Context-Free
Languages
(Grammars)
Languages
Accepted by
NPDAs

COMP 335



COMP 335
*
Converting 
NPDAs
to
Context-Free Grammars
 
Proof - step 2

COMP 335


COMP 335
*
Given any NPDA    ,  

context-free grammar     such that:
we will construct a

COMP 335





COMP 335
*
Intuition:
The grammar G  simulates the 
computation of 
A derivation in Grammar     : 
Current configuration in NPDA 
Input processed
Stack content
terminals
variables

COMP 335






COMP 335
*
Some Necessary Modifications 
Modify (if necessary) the NPDA M  so that: 

1) The stack is never empty except at the end


2)        has a single final state and empties 
     the stack when it accepts a string

3) Transitions in M are in a special form:
    (qi,a,A)={c1,c2,…,cn}, where ci=(qj,) or ci=(qj,BC)
    for every symbol a in ΣU{}

COMP 335



COMP 335
*
1. Modify the PDA so that 
    the stack is never empty
    during computation  

Stack
OK

OK

NOT OK

COMP 335
*









COMP 335
*



Introduce the new symbol        to mark 
the bottom of the stack





COMP 335
*
















COMP 335
*
Original PDA









At the beginning, insert      into the stack
original 
initial state
new 
initial state

COMP 335
*








COMP 335
*






halting state
Convert all transitions so that 
after popping      the automaton halts 

pop
pop

#
#

,


COMP 335
*

















COMP 335
*
PDA










Empty stack
2. Modify the PDA so that at end,
    it empties stack and 
    has a unique accept state
Old accept states

New 
accept 
state




,




,




,

COMP 335
*










COMP 335
*
3. Modify the PDA so that it has no
    transitions popping   :







COMP 335
*














COMP 335
*




Example of a NPDA in correct form:

COMP 335













COMP 335
*
The Grammar Construction
In grammar      :
Terminals:
Input symbols of NPDA 
states
Stack symbol
Variables:

COMP 335




COMP 335
*


For each transition
We add production

COMP 335







COMP 335
*
For each transition
We add productions


For all possible states
in the automaton 

COMP 335







COMP 335
*
Start Variable:
Stack bottom symbol
Start state
final state

COMP 335



COMP 335
*
Example:





Grammar production:

COMP 335













COMP 335
*
Example:





Grammar productions:

COMP 335













COMP 335
*
Example:





Grammar production:

COMP 335












COMP 335
*
Resulting Grammar:

COMP 335






COMP 335
*
The resulting grammar obtained by converting an NPDA in general includes many useless variables and productions, which can be removed, if you wish 

COMP 335





COMP 335
*
After consistent replacement of the variables and removing useless variables and rules, we get the following equivalent CFG for L(M), where A=(q01q0), B=(q00q0), S=(q0$qf)

COMP 335



COMP 335
*
Derivation of string
Using:  A=(q01q0), B=(q00q0), S=(q0$qf), we get:

COMP 335










COMP 335
*
In general:
if and only if
the NPDA goes from         to
by reading string           and
the stack doesn’t change below
and then        is removed from stack  

COMP 335









COMP 335
*
Therefore:
if and only if
is accepted by the NPDA

COMP 335





COMP 335
*
In general:
If and
Only if
Grammar
PDA

COMP 335
*








COMP 335
*
Thus:
If and
Only if
Grammar
generates
PDA accepts

COMP 335
*










COMP 335
*
Therefore:
For any NPDA
there is a context-free grammar
that accepts the same language
Context-Free
Languages
(Grammars)
Languages
Accepted by
NPDAs

COMP 335



COMP 335
*
Deterministic PDA

DPDA
 

COMP 335


COMP 335
*
Deterministic PDA: DPDA




Allowed transitions:
(deterministic choices)

COMP 335








COMP 335
*
Allowed transitions:






(deterministic choices)

COMP 335












COMP 335
*



Not allowed:
(non deterministic choices)




COMP 335












COMP 335
*
DPDA example








COMP 335












COMP 335
*
The language
is  deterministic context-free

COMP 335



COMP 335
*
Definition:
L is a deterministic context-free language
if there exists some DPDA that accepts it

COMP 335


COMP 335
*
Example of Non-DPDA (NPDA)







COMP 335










COMP 335
*







Not allowed in DPDAs, since
it  matches the transitions from q0 to q0

COMP 335









COMP 335
*

NPDA’s are more powerful 
(expressive) than DPDA’s


COMP 335


COMP 335
*
Deterministic
Context-Free
Languages
(DPDA)
Context-Free
Languages
NPDAs
Since every DPDA is also a NPDA
It holds that:

COMP 335



COMP 335
*
We will actually show:
Deterministic
Context-Free
Languages
(DPDA)
Context-Free
Languages
(NPDA)
We will show that there exists
a context-free language     which is not
accepted by any DPDA

COMP 335





COMP 335
*
An example of such a language is:
We will show:
	     is context-free

	     is not deterministic context-free


COMP 335






COMP 335
*
Language     is context-free
Context-free grammar for     : 

COMP 335







COMP 335
*
is not deterministic context-free
Theorem:
The language
(there is no DPDA that accepts    ) 

COMP 335




COMP 335
*
Proof:
Suppose that
is a deterministic CFL
Therefore:
there is a DPDA      that accepts 

COMP 335





COMP 335
*





DPDA       for

accepts

accepts

COMP 335








COMP 335
*





DPDA          for 
Such a path exists in M because L is assumed 
to be deterministic.


COMP 335







COMP 335
*
(This can be shown later using the pumping 
 lemma for context-free languages)
L’={anbn: n≥0} ∪ {anb2n:n≥ 0} ∪ {anbncn: n≥0}
is not context-free.


Regular languages
Context-free languages

COMP 335


COMP 335
*
We will use M to construct an NPDA for:
which is a contradiction!
L’={anbn: n≥0} ∪ {anb2n:n≥ 0} ∪ {anbncn: n≥0}

COMP 335


COMP 335
*
Modify
Replace
with



















COMP 335









COMP 335
*












Connect final states of     to final states of    .
This yields the following NPDA that accepts:
bn
L’={anbn: n≥0} ∪ {anb2n:n≥ 0} ∪ {anbncn: n≥0}

COMP 335











COMP 335
*
Since L’ is accepted by an NPDA, 
we conclude that      is CF.
but this is a contradiction
(since        is not context-free)

COMP 335




COMP 335
*
Therefore:
there is no DPDA that accepts L 
For the non-deterministic CFL:

COMP 335


UNKNOWN-0.unknown

UNKNOWN-1.unknown

UNKNOWN-2.unknown

UNKNOWN-3.unknown

UNKNOWN-4.unknown

UNKNOWN-5.unknown

UNKNOWN-6.unknown

UNKNOWN-7.unknown

UNKNOWN-8.unknown

UNKNOWN-9.unknown

UNKNOWN-10.unknown











=









Í









G









M









)
(
)
(
M
L
G
L
=









Ê









)
(
)
(
M
L
G
L
=









M









G









G









M









)
(
)
(
M
L
G
L
=









q
0









q
1









2
q









$
$
,
®
l









w
A
®
,
l









l
®
a
a
,









M









w
A
®









a









G









$
$
,
S
®
l









L
L
L
L
L
Þ
Þ
Þ
m
k
V
V
V
S
2
1
2
1
s
s
s









M









L









1
s









2
s









k
s









1
+
k
s









$









1
V









2
V









m
V









:
G









:
M









n
k
k
m
k
X
X
S
s
s
s
s
s
s
L
L
L
L
L
L
1
1
1
1
+
Þ
Þ
Þ
Þ









,$)
,
(
$)
,
,
(
$)
,
,
(
,$)
,
(
2
1
1
1
1
1
1
1
1
0
l
s
s
s
s
s
s
s
s
s
s
q
X
X
q
S
q
q
m
n
k
n
k
k
n
k
k
f
L
f
L
L
f
L
f
L
L
f
L
L
+
+
+









n
S
s
s
s
L
L
L
L
2
1
Þ
Þ









L
L









n
s









l
®
®
®
®
T
Ta
T
b
S
aSTb
S









$
$
,
S
®
l









$
$
,
®
l









l
l
l
l
l
®
®
®
®
T
Ta
T
b
S
aSTb
S
,
,
,
,









l
®
®
®
®
T
Ta
T
b
S
aSTb
S









l
l
®
®
b
b
a
a
,
,









l
®
®
®
®
T
Ta
T
b
S
aSTb
S
.
4
.
3
.
2
.
1









abab
abTab
abTb
aSTb
S
4
3
2
1
Þ
Þ
Þ
Þ









0
q









$
$
,
®
l









$









a









b









$
$
,
S
®
l









l
l
l
l
l
®
®
®
®
T
Ta
T
b
S
aSTb
S
,
,
,
,









l
l
®
®
b
b
a
a
,
,









S









S









l
l
l
l
l
®
®
®
®
T
Ta
T
b
S
aSTb
S
,
,
,
,









l
l
®
®
b
b
a
a
,
,









$
$
,
®
l









$
$
,
S
®
l









l
,
$
®
$









l
l
l
l
l
®
®
®
®
T
Ta
T
b
S
aSTb
S
,
,
,
,









l
l
®
®
b
b
a
a
,
,









T









aSTb
S
Þ









$
$
,
S
®
l









abTb
aSTb
S
Þ
Þ









abTab
abTb
aSTb
S
Þ
Þ
Þ









T









abab
abTab
abTb
aSTb
S
Þ
Þ
Þ
Þ









$
$
,
®
l









w
A
®
,
l









l
®
a
a
,









$
$
,
S
®
l









G









w
S
*
Þ









M









,$)
,
*(
,$)
,
(
2
0
l
q
w
q
f









w









)
(
)
(
M
L
G
L
=









w









)
(
)
(
M
L
G
L
=









)
(
)
(
G
L
M
L
=









G









K
K
K
K
L
abc
ABC
abc
S
Þ
Þ
Þ
Þ









$









a









#









$#
,$
®
l









i
q









j
q









s
®
x
s
,









j
q









x
x
®
,
l









}
{#
-
G
Î
"
x









f
q









l
l
®
x
,









l
l
®
#
,









y
®
l
s
,









t
t
s
y
®
,









}
{#
-
G
Î
"
t









l









l
l
®
$
,









0
q









f
q









a
,
$
®
0
$









a
,
0
®
00









a
,
1
®
l









b
,
$
®
1
$









b
,
1
®
11









b
,
0
®
l









)}
(
)
(
:
{
)
(
w
n
w
n
w
M
L
b
a
=
=









marker
 
end
stack 
 
:
$









)
(
j
i
Bq
q









G









i
q









j
q









l
®
B
a
,









a
Bq
q
j
i
®
)
(









)
)(
(
)
(
k
l
l
j
k
i
Dq
q
Cq
q
a
Bq
q
®









CD
B
a
®
,









l
k
q
q
,









)
$
(
f
o
q
q









a
q
q
®
)
1
(
0
0









)
$
)(
1
(
|
)
$
)(
1
(
)
$
(
)
$
)(
1
(
|
)
$
)(
1
(
)
$
(
0
0
0
0
0
0
0
0
0
0
0
0
0
f
f
f
f
f
f
f
q
q
q
q
b
q
q
q
q
b
q
q
q
q
q
q
b
q
q
q
q
b
q
q
®
®









l
®
)
$
(
0
f
q
q









)
1
)(
1
(
|
)
1
)(
1
(
)
1
(
)
1
)(
1
(
|
)
1
)(
1
(
)
1
(
0
0
0
0
0
0
0
0
0
0
0
0
0
f
f
f
f
f
f
f
q
q
q
q
b
q
q
q
q
b
q
q
q
q
q
q
b
q
q
q
q
b
q
q
®
®









)
$
)(
0
(
|
)
$
)(
0
(
)
$
(
)
$
)(
0
(
|
)
$
)(
0
(
)
$
(
0
0
0
0
0
0
0
0
0
0
0
0
0
f
f
f
f
f
f
f
q
q
q
q
a
q
q
q
q
a
q
q
q
q
q
q
a
q
q
q
q
a
q
q
®
®









able
start vari
:
)
$
(
0
f
q
q









)
0
)(
0
(
|
)
0
)(
0
(
)
0
(
)
0
)(
0
(
|
)
0
)(
0
(
)
0
(
0
0
0
0
0
0
0
0
0
0
0
0
0
f
f
f
f
f
f
f
q
q
q
q
a
q
q
q
q
a
q
q
q
q
q
q
a
q
q
q
q
a
q
q
®
®









b
q
q
a
q
q
®
®
)
0
(
)
1
(
0
0
0
0









aBB
b
B
bAA
a
A
bAS
aBS
S
|
|
|
|
®
®
®
l









abba









Þ
)
$
(
0
f
q
q









Þ
)
$
)(
0
(
0
0
0
f
q
q
q
q
a









Þ
)
$
(
0
f
q
q
ab









Þ
)
$
)(
1
(
0
0
0
f
q
q
q
q
abb









Þ
)
$
(
0
f
q
q
abba









abba









abba
abbaS
abbAS
abS
aBS
S
Þ
Þ
Þ
Þ
Þ









w
Aq
q
j
i
*
Þ
)
(









i
q









j
q









A









A









w









w
q
q
f
*
Þ
)
$
(
0









w









wB
Aq
q
j
i
*
Þ
)
(









)
,
,
(
)
,
,
(
B
q
A
w
q
j
i
l
*
f









w
q
q
f
*
Þ
)
$
(
0









)
,
,
(
,$)
,
(
0
l
l
f
q
w
q
*
f









q
2









w
b
a
®
,









1
q









2
q









w
b
®
,
l









1
,
w
b
®
l









q
3









2
,
w
c
®
l









1
,
w
b
a
®









2
,
w
c
a
®









2
,
w
b
a
®









2
,
w
b
a
®









a
,
l
®
a









b
,
a
®
l









}
0
:
{
)
(
³
=
n
b
a
M
L
n
n









b
b
a
a
®
®
l
l
,
,









l
,
l
®
l









l
l
®
®
b
b
a
a
,
,









}
{
)
(
R
ww
M
L
=









Ì









Î
L









Ï
L









L









}
{
}
{
2
n
n
n
n
b
a
b
a
L
È
=









0
³
n









L









}
{
n
n
b
a









}
{
2
n
n
b
a









}
{
}
{
2
n
n
n
n
b
a
b
a
È









2
1
|
S
S
S
®









l
|
1
1
b
aS
S
®









l
|
2
2
bb
aS
S
®









}
{
}
{
2
n
n
n
n
b
a
b
a
L
È
=









L









M









L









M









n
n
b
a









n
b









n
n
b
a
2









n
n
b
a









}
{
}
{
2
n
n
n
n
b
a
b
a
L
È
=









}
{
}
{
2
n
n
n
n
b
a
b
a
L
È
=









*
*
b
a









n
n
b
a









M
¢









}
{
}
{
)
(
2
n
n
n
n
b
a
b
a
M
L
È
=









}
{
}
{
)
(
2
n
n
n
n
c
a
c
a
M
L
È
=
¢









b









c









n
c









n
n
c
a









n
n
b
a









n
c









M









n
n
c
a









l









M
¢









'
L









}
{
}
{
2
n
n
n
n
b
a
b
a
L
È
=
