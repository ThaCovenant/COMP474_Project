



















Languages and Finite Automata


COMP 335
*
Closure Properties
of 
Context-Free languages
 
*

COMP 335


COMP 335
*
Context-free languages 
are closed under:
Union
is context free
is context free


is context-free
Union

COMP 335





COMP 335
*
Example
Union
Language
Grammar

COMP 335








COMP 335
*
In general:
The grammar of the union      
has new start variable
and additional production
For  context-free languages
with context-free grammars
and start variables 

COMP 335








COMP 335
*
Context-free languages 
are closed under:
Concatenation
is context free
is context free


is context-free
Concatenation

COMP 335





COMP 335
*
Example
Concatenation
Language
Grammar

COMP 335








COMP 335
*
In general:
The grammar of the concatenation      
has new start variable
and additional production
For  context-free languages
with context-free grammars
and start variables 

COMP 335








COMP 335
*
Context-free languages 
are closed under:
Star-operation
is context free

is context-free
Star Operation

COMP 335




COMP 335
*
Example
Language
Grammar
Star Operation

COMP 335






COMP 335
*
In general:
The grammar of the star operation      
has new start variable
and additional production
For  context-free language
with context-free grammar
and start variable 

COMP 335








COMP 335
*
“Negative” Properties of
 
Context-Free Languages
 

COMP 335


COMP 335
*
Context-free languages
are not closed under:
intersection
is context free
is context free


not necessarily
context-free
Intersection

COMP 335





COMP 335
*
Example
Context-free:
Context-free:
is NOT CF.
Intersection

COMP 335







COMP 335
*
Context-free languages
are not closed under:
complement
is context free

not necessarily
context-free
Complement

COMP 335




COMP 335
*
is NOT CF.
Example
Context-free:
Context-free:
Complement

COMP 335







COMP 335
*
Intersection
of 
Context-free languages
and 
Regular Languages
 

COMP 335


COMP 335
*
The intersection of
               a context-free language and
               a regular language
is a context-free language 
context free
regular


context-free

COMP 335





COMP 335
*
for
for 

NPDA
DFA
Construct a new NPDA machine
that accepts 
Machine

Machine
context-free
regular
simulates in parallel          and 

COMP 335











COMP 335
*




transition


transition
NPDA
DFA


transition
NPDA




COMP 335














COMP 335
*




transition

NPDA
DFA


transition
NPDA




COMP 335












COMP 335
*



initial state

initial state
NPDA
DFA

Initial state
NPDA




COMP 335








COMP 335
*



final state

final states
NPDA
DFA

final states
NPDA











COMP 335










COMP 335
*
Example:






NPDA
context-free

COMP 335















COMP 335
*


DFA
regular

COMP 335






COMP 335
*
Automaton for:






NPDA
context-free

COMP 335













COMP 335
*
simulates in parallel          and 
accepts string         
if and only if
accepts string          and         
accepts string         
In General:

COMP 335












COMP 335
*
Therefore:
       is NPDA
is context-free

is context-free


COMP 335





COMP 335
*
Applications 
of 
Regular Closure

COMP 335


COMP 335
*
The intersection of
               a context-free language and
               a regular language
is a context-free language 
context free
regular


context-free
Regular Closure

COMP 335





COMP 335
*
An Application of Regular Closure
Prove that:
is context-free

COMP 335



COMP 335
*
We know that:
is context-free

COMP 335



COMP 335
*
is regular

is regular
We also know:

COMP 335




COMP 335
*
regular
context-free


context-free
is context-free
(regular closure)


COMP 335






COMP 335
*
Another Application of Regular Closure
Prove that:
is not context-free

COMP 335



COMP 335
*
context-free
regular
context-free
If
is context-free
Then
Impossible!!!
(regular closure)
Therefore,        is not context free 

COMP 335




COMP 335
*
Decidable Properties
of 
Context-Free Languages

COMP 335


COMP 335
*
Membership Question:
Given a string w and CFG
Decide if
Membership Algorithms:
Parsers
	 Exhaustive search parser

	 CYK parsing algorithm


COMP 335




COMP 335
*
Empty Language Question:
for context-free grammar         
find if   
Algorithm:
	Remove useless variables
	Check if the start variable S is useless or not 


COMP 335




COMP 335
*
Infinite Language Question:
for a context-free grammar         
find if            is infinite   
Algorithm:
1. Remove useless variables
2. Remove unit and       productions
3. Create dependency graph for variables
4. If there is a loop in the dependency graph
    then L(G) is infinite

COMP 335




COMP 335
*
Example:




Dependency graph
Infinite language 

COMP 335







COMP 335
*

COMP 335




UNKNOWN-0.unknown

UNKNOWN-1.unknown











1
L









2
L









2
1
L
L
È









l
|
1
1
b
aS
S
®









l
|
|
2
2
2
b
bS
a
aS
S
®









}
{
1
n
n
b
a
L
=









}
{
2
R
ww
L
=









2
1
|
S
S
S
®









}
{
}
{
R
n
n
ww
b
a
L
È
=









2
1
|
S
S
S
®









2
1
,
L
L









2
1
,
G
G









2
1
,
S
S









2
1
L
L
È









S









1
L









2
1
L
L









2
1
S
S
S
®









}
}{
{
R
n
n
ww
b
a
L
=









2
1
S
S
S
®









2
1
L
L









L









*
L









l
|
aSb
S
®









}
{
n
n
b
a
L
=









l
|
1
1
SS
S
®









*
}
{
n
n
b
a
L
=









L









G









S









*
L









1
S









1
L









2
L









2
1
L
L
Ç









}
{
1
m
n
n
c
b
a
L
=









l
l
|
|
cC
C
aAb
A
AC
S
®
®
®









}
{
2
m
m
n
c
b
a
L
=









l
l
|
|
bBc
B
aA
A
AB
S
®
®
®









}
0
:
{
2
1
>=
=
Ç
n
c
b
a
L
L
n
n
n









L









L









}
0
:
{
2
1
2
1
>=
=
Ç
=
È
n
c
b
a
L
L
L
L
n
n
n









1
L









2
L









2
1
L
L
Ç









1
M









2
M









M









1
q









2
q









c
b
a
®
,









1
p









2
p









a









1
1
,
p
q









2
2
,
p
q









c
b
®
,
l









c
b
®
,
l









1
2
,
p
q









0
q









0
p









0
0
,
p
q









1
q









1
p









1
1
,
p
q









2
p









2
1
,
p
q









l
l
l
®
,









l
l
®
,$









1
,
®
l
b









1
,
®
l
a









l
®
1
,
d









l
®
1
,
c









0
q









1
q









2
q









3
q









1
M









}
}
,
{
,
}
,
{
|,
|
|
|
:
{
*
2
*
1
2
1
2
1
1
d
c
w
b
a
w
w
w
w
w
L
Î
Î
=
=









0
p









2
M









*
2
}
,
{
c
a
L
=









c
a
,









}
0
:
{
2
1
³
=
Ç
n
c
a
L
L
n
n









0
0
,
p
q









0
1
,
p
q









0
2
,
p
q









0
3
,
p
q









M









w









)
(
)
(
)
(
2
1
M
L
M
L
M
L
Ç
=









)
(
)
(
2
1
M
L
M
L
Ç









1
L









2
L









2
1
L
L
Ç









}
0
,
100
:
{
³
¹
=
n
n
b
a
L
n
n









}
0
:
{
³
=
n
b
a
L
n
n









}
{
100
100
1
b
a
L
=









}
{
)
)
((
100
100
*
1
b
a
b
a
L
L
-
+
=









}
0
:
{
³
n
b
a
n
n









1
}
0
:
{
L
n
b
a
n
n
Ç
³









1
}
0
:
{
}
0
,
100
:
{
L
n
b
a
n
n
b
a
L
n
n
n
n
Ç
³
=
³
¹
=









}
:
{
c
b
a
n
n
n
w
L
=
=
=









}
0
:
{
*}
*
*
{
³
=
Ç
n
c
b
a
c
b
a
L
n
n
n









L









G









)
(
G
L
w
Î









Æ
=
)
(
G
L









G









)
(
G
L









l









cBS
C
bb
bB
B
a
aCb
A
AB
S
®
®
®
®
|
|









S









A









B









C









cBS
C
bb
bB
B
a
aCb
A
AB
S
®
®
®
®
|
|









acbbSbbb
acBSbB
aCbB
AB
S
Þ
Þ
Þ
Þ









i
i
bbb
S
acbb
bbb
S
acbb
acbbSbbb
S
)
(
)
(
)
(
)
(
2
2
*
*
*
Þ
Þ
Þ
