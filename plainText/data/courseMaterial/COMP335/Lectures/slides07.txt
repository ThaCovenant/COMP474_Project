



















Languages and Finite Automata


COMP 335
*
Context-Free Grammars (CFG’s)
 
*

COMP 335


COMP 335
*
Example
 
A context-free grammar     :
A derivation:

COMP 335





COMP 335
*
 
A context-free grammar     :
Another derivation:

COMP 335





COMP 335
*
(((( ))))
Describes nested parentheses:

COMP 335





COMP 335
*
A context-free grammar     :
A derivation:
Example

COMP 335






COMP 335
*
A context-free grammar     :
Another derivation:

COMP 335






COMP 335
*

COMP 335






COMP 335
*
A context-free grammar     :
A derivation:
Example

COMP 335





COMP 335
*
A context-free grammar     :
A derivation:

COMP 335





COMP 335
*
() ((( ))) (( ))
Describes 
matched 
parentheses:

COMP 335





COMP 335
*
Definition: Context-Free Grammars
Grammar
Productions of the form:
String of variables 
and terminals
Variables
Terminal
symbols
Start
variable
Variable

COMP 335




COMP 335
*


COMP 335




COMP 335
*
Context-Free Languages

Definition: A language       is context-free

if and only if

there is a context-free grammar       
that generates it. That is,  

COMP 335





COMP 335
*
Derivation Order
 
Leftmost derivation:
Rightmost derivation:

COMP 335





COMP 335
*
Leftmost derivation:
Rightmost derivation:

COMP 335



COMP 335
*
Derivation Trees
 

COMP 335


COMP 335
*
 




COMP 335









COMP 335
*







COMP 335












COMP 335
*









COMP 335














COMP 335
*










COMP 335















COMP 335
*










Derivation Tree

COMP 335
















COMP 335
*
yield










Derivation Tree

COMP 335

















COMP 335
*
Partial Derivation Trees 
 



Partial derivation tree

COMP 335









COMP 335
*
 






Partial derivation tree

COMP 335









COMP 335
*
 






Partial derivation tree
sentential
form
yield

COMP 335










COMP 335
*
 
Same derivation tree
Sometimes “derivation” matters only, not the 
order in which the productions are applied.
Leftmost:
 Rightmost:




















COMP 335




COMP 335
*
So far, we focused on generative aspect of CF grammars.

What about its analytical aspect?
This aspect relates to Parsing…..
Parsing describes finding a sequence of productions (in a CFG G) by which a given string w is derived

COMP 335


COMP 335
*

Parser

   Input
string w

Derivation
    of w?
Grammar


COMP 335


COMP 335
*
Example:

Parser


derivation
?


COMP 335




COMP 335
*
Exhaustive Search
Phase 1:
All possible derivations of length 1
Find derivation of

COMP 335





COMP 335
*

COMP 335




COMP 335
*
Phase 2
Phase 1









COMP 335






COMP 335
*
Phase 2
Phase 3

COMP 335







COMP 335
*
Final result of exhaustive search

Parser


derivation
Inputs:
(top-down parsing)



COMP 335





COMP 335
*
Time complexity of exhaustive search
Suppose there are no productions of the form
# of phases for generating any string     is at 
most          .  Why?    

COMP 335






COMP 335
*
Time for phase 1:
possible derivations
For a grammar with      rules 

COMP 335





COMP 335
*
Time for phase 2:
possible derivations

COMP 335




COMP 335
*
Time for phase          :
possible derivations:
which is exponential in the length of w

COMP 335





COMP 335
*
Total time/cost needed for parsing    :
O(k2|w|) is extremely bad!!!
Cost at 
phase 1
at phase 2
at phase 2|w|

COMP 335




COMP 335
*
There are faster algorithms for specific grammars. For example, the Simple-grammar
S-grammar:
symbol
string
of variables
appears once
where pair

COMP 335




COMP 335
*
S-grammar example:
Each string w has a unique derivation:

COMP 335




COMP 335
*
In the exhaustive search parsing
there is only one choice in each phase
For S-grammars:
Total time for parsing string    :
Time for each phase:   

COMP 335





COMP 335
*
For general context-free grammars:
There exists an efficient parsing 
algorithm for CFG’s in CNF that 
parses strings w with n symbols 
in time O(n3 |P|), P is the number of
rules in the equivalent CNF grammar 
Check out the CYK membership algorithm [1967] in 
Sec. 6.3 (as the basis of the above efficient method)

COMP 335


COMP 335
*
Ambiguity
 

COMP 335


COMP 335
*










leftmost derivation

COMP 335















COMP 335
*










leftmost derivation

COMP 335















COMP 335
*






































Two derivation trees

COMP 335




COMP 335
*
The grammar
is ambiguous:
since there is a string, namely
, with at least 2 derivation trees







































COMP 335




COMP 335
*
has at least two leftmost derivations
The grammar
is ambiguous:
since string

COMP 335






COMP 335
*
Definition:
A context-free grammar G is ambiguous
if there exists a string w in L(G) with
two or more “distinct” derivation trees

COMP 335


COMP 335
*
Alternatively, we may say:
Ambiguity of a grammar      implies 
existence of two or more leftmost 
(or rightmost) derivations

COMP 335



COMP 335
*
Why do we care about ambiguity?




















Consider 

COMP 335
























COMP 335
*





















COMP 335























COMP 335
*





















COMP 335


































COMP 335
*










Correct result:

COMP 335


















COMP 335
*
	 So we should eliminate ambiguity, 

   when possible
	 Ambiguity is not desired for 

  programming languages because it 
  may result in different meanings
 of (say a mathematical) expression!

COMP 335


COMP 335
*
We may be able to fix the ambiguity:
New non-ambiguous grammar:

COMP 335




COMP 335
*














COMP 335


















COMP 335
*













Unique derivation tree

COMP 335
















COMP 335
*
The grammar     :   
is non-ambiguous:
Every string                  has
a unique derivation tree 

COMP 335





COMP 335
*
Another Ambiguous Grammar
IF_STMT
if EXPR then STMT
if EXPR then STMT else STMT

COMP 335




COMP 335
*
if expr1 then if expr2 then stmt1 else stmt2

IF_STMT

expr1

then

else

if

expr2

then

STMT

stmt1

if

IF_STMT

expr1

then

else

if

expr2

then

STMT

stmt2

if

stmt1

stmt2
if expr1 then (if expr2 then stmt1 else stmt2)
if expr1 then (if expr2 then stmt1) else stmt2

COMP 335


COMP 335
*
Inherent Ambiguity

Some context-free languages
have only ambiguous grammars
Example:

COMP 335






COMP 335
*
The string 
has two derivation trees









COMP 335










UNKNOWN-0.unknown

UNKNOWN-1.unknown

UNKNOWN-2.unknown

UNKNOWN-3.unknown

UNKNOWN-4.unknown

UNKNOWN-5.unknown

UNKNOWN-6.unknown

UNKNOWN-7.unknown

UNKNOWN-8.unknown

UNKNOWN-9.unknown

UNKNOWN-10.unknown

UNKNOWN-11.unknown

UNKNOWN-12.unknown

UNKNOWN-13.unknown

UNKNOWN-14.unknown

UNKNOWN-15.unknown

UNKNOWN-16.unknown

UNKNOWN-17.unknown

UNKNOWN-18.unknown

UNKNOWN-19.unknown

UNKNOWN-20.unknown

UNKNOWN-21.unknown

UNKNOWN-22.unknown

UNKNOWN-23.unknown

UNKNOWN-24.unknown

UNKNOWN-25.unknown

UNKNOWN-26.unknown

UNKNOWN-27.unknown

UNKNOWN-28.unknown

UNKNOWN-29.unknown

UNKNOWN-30.unknown

UNKNOWN-31.unknown

UNKNOWN-32.unknown

UNKNOWN-33.unknown

UNKNOWN-34.unknown

UNKNOWN-35.unknown

UNKNOWN-36.unknown

UNKNOWN-37.unknown

UNKNOWN-38.unknown

UNKNOWN-39.unknown

UNKNOWN-40.unknown

UNKNOWN-41.unknown

UNKNOWN-42.unknown

UNKNOWN-43.unknown

UNKNOWN-44.unknown

UNKNOWN-45.unknown

UNKNOWN-46.unknown

UNKNOWN-47.unknown

UNKNOWN-48.unknown

UNKNOWN-49.unknown

UNKNOWN-50.unknown

UNKNOWN-51.unknown

UNKNOWN-52.unknown

UNKNOWN-53.unknown

UNKNOWN-54.unknown











l
®
®
S
aSb
S









aabb
aaSbb
aSb
S
Þ
Þ
Þ









G









aaabbb
aaaSbbb
aaSbb
aSb
S
Þ
Þ
Þ
Þ









l
®
®
S
aSb
S









=
)
(
G
L









}
0
:
{
³
n
b
a
n
n









l
®
®
®
S
bSb
S
aSa
S









abba
abSba
aSa
S
Þ
Þ
Þ









abaaba
abaSaba
abSba
aSa
S
Þ
Þ
Þ
Þ









l
®
®
®
S
bSb
S
aSa
S









=
)
(
G
L









}*}
,
{
:
{
b
a
w
ww
R
Î









l
®
®
®
S
SS
S
aSb
S









ab
abS
aSbS
SS
S
Þ
Þ
Þ
Þ









abab
abaSb
abS
aSbS
SS
S
Þ
Þ
Þ
Þ
Þ









l
®
®
®
S
SS
S
aSb
S









}
prefix
any
in 
         
)
(
)
(
  
and
),
(
)
(
:
{
v
v
n
v
n
w
n
w
n
w
b
a
b
a
³
=









=
)
(
G
L









x
A
®









)
,
,
,
(
P
S
T
V
G
=









}
,
:
{
)
(
*
*
T
w
w
S
w
G
L
Î
Þ
=









L









G









)
(
G
L
L
=









AB
S
®
.
1









l
®
®
A
aaA
A
.
3
.
2









l
®
®
B
Bb
B
.
5
.
4









aab
aaAb
Ab
ABb
AB
S
3
2
5
4
1
Þ
Þ
Þ
Þ
Þ









aab
aaBb
aaB
aaAB
AB
S
5
4
3
2
1
Þ
Þ
Þ
Þ
Þ









l
|
A
B
bBb
A
aAB
S
®
®
®









abbbb
abbBbb
abAb
abBb
aA
aAB
S
Þ
Þ
Þ
Þ
Þ
Þ









abbbb
abbbbB
abbBbbB
abAbB
abBbB
aAB
S
Þ
Þ
Þ
Þ
Þ
Þ









AB
S
Þ









AB
S
®









l
|
aaA
A
®









l
|
Bb
B
®









S









B









A









AB
S
®









aaAB
AB
S
Þ
Þ









a









A









aaABb
aaAB
AB
S
Þ
Þ
Þ









B









b









aaBb
aaABb
aaAB
AB
S
Þ
Þ
Þ
Þ









l









aab
aaBb
aaABb
aaAB
AB
S
Þ
Þ
Þ
Þ
Þ









aab
aaBb
aaABb
aaAB
AB
S
Þ
Þ
Þ
Þ
Þ









aab
b
aa
=
ll









AB
S
Þ









AB
S
®









l
|
aaA
A
®









l
|
Bb
B
®









aaAB
AB
S
Þ
Þ









aaAB
AB
S
Þ
Þ









aaAB









aab
aaBb
aaB
aaAB
AB
S
Þ
Þ
Þ
Þ
Þ









aab
aaAb
Ab
ABb
AB
S
Þ
Þ
Þ
Þ
Þ









l
®
®
®
®
S
bSa
S
aSb
S
SS
S









aabb









l
|
|
|
bSa
aSb
SS
S
®









l
Þ
Þ
Þ
Þ
S
bSa
S
aSb
S
SS
S









l
Þ
Þ
Þ
Þ
S
bSa
S
aSb
S
SS
S









aSb
S
SS
S
Þ
Þ









S
SS
S
bSaS
SS
S
aSbS
SS
S
SSS
SS
S
Þ
Þ
Þ
Þ
Þ
Þ
Þ
Þ









ab
aSb
S
abSab
aSb
S
aaSbb
aSb
S
aSSb
aSb
S
Þ
Þ
Þ
Þ
Þ
Þ
Þ
Þ









S
SS
S
aSbS
SS
S
SSS
SS
S
Þ
Þ
Þ
Þ
Þ
Þ









aaSbb
aSb
S
aSSb
aSb
S
Þ
Þ
Þ
Þ









aabb
aaSbb
aSb
S
Þ
Þ
Þ









aabb









aabb
aaSbb
aSb
S
Þ
Þ
Þ









l
®
A









B
A
®









w









|
|
2
w









k









k









2
k









|
|
2
w
k









|
|
2
w









|
|
2
2
w
k
k
k
+
+
+
L









ax
A
®









)
,
(
a
A









c
S
bSS
S
aS
S
®
®
®









abcc
abcS
abSS
aS
S
Þ
Þ
Þ
Þ









w









|
|
w









1









a
E
E
E
E
E
E
|
)
(
|
|
*
+
®









a
a
a
w
*
+
=









E









+









*









a
a
a
E
a
a
E
E
a
E
a
E
E
E
*
4
4
2
4
1
+
Þ
*
+
Þ
*
+
Þ
+
Þ
+
Þ









a
E
E
E
E
E
E
|
)
(
|
|
*
+
®









a
a
a
E
a
a
E
E
a
E
E
E
E
E
E
*
+
Þ
*
+
Þ
*
+
Þ
*
+
Þ
*
Þ
4
4
4
1
2









a
E
E
E
E
E
E
|
)
(
|
|
*
+
®









a
E
E
E
E
E
E
|
)
(
|
|
*
+
®









a
a
a
*
+









a
a
a
w
*
+
=









2
=
a









2
2
2
*
+









2









6
2
2
2
=
*
+









8
2
2
2
=
*
+









4









6









8









6
2
2
2
=
*
+









a
F
E
F
F
T
F
T
T
T
E
T
E
E
®
®
®
*
®
®
+
®
)
(









a
F
E
F
F
T
F
T
T
T
E
T
E
E
6
5
4
3
2
1
)
(
®
®
®
*
®
®
+
®









a
a
a
F
a
a
F
F
a
F
T
a
T
a
T
F
T
T
T
E
E
*
+
Þ
*
+
Þ
*
+
Þ
*
+
Þ
+
Þ
+
Þ
+
Þ
+
Þ
6
6
4
3
6
4
2
1









E









T









F









a









a
a
a
w
*
+
=









a
a
a
*
+









G









)
(
G
L
w
Î









®









|









}
{
}
{
m
m
n
m
n
n
c
b
a
c
b
a
L
È
=









l
|
|
1
1
aAb
A
A
c
S
S
®
®









l
|
|
2
2
bBc
B
B
aS
S
®
®









2
1
|
S
S
S
®









n
n
n
c
b
a









1
S









2
S









c
