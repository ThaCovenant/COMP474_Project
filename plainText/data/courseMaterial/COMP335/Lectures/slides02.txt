



















Languages and Finite Automata


COMP 335
*
    Deterministic 
Finite Automata (DFA)
*

COMP 335


COMP 335
*
Finite Automaton


Input



String
  
Output
String
Finite
Automaton

COMP 335


COMP 335
*
Finite Accepter
 


Input



“Accept/Yes”
     or
“Reject/No”
String
Finite
Automaton
Output

COMP 335


COMP 335
*
Transition Graph for a DFA
 
initial
state
final/accept
  state
state
transition
Input string: abba 









COMP 335

















COMP 335
*
Initial Configuration
 








Input String


COMP 335





















COMP 335
*
Reading the Input
 










COMP 335





















COMP 335
*

 










COMP 335





















COMP 335
*

 










COMP 335





















COMP 335
*

  










COMP 335





















COMP 335
*






Output: “accept”


Input finished


COMP 335





















COMP 335
*
Rejection
 










COMP 335




















COMP 335
*

 










COMP 335




















COMP 335
*

 










COMP 335




















COMP 335
*

 










COMP 335




















COMP 335
*







Output:
“reject”

Input finished


COMP 335




















COMP 335
*
Another Rejection
 










COMP 335


















COMP 335
*
 








Output:
“reject”


COMP 335


















COMP 335
*
Another Example






COMP 335












COMP 335
*






COMP 335












COMP 335
*






COMP 335












COMP 335
*






COMP 335












COMP 335
*





Output: “accept”
Input finished

COMP 335












COMP 335
*
Rejection






COMP 335












COMP 335
*






COMP 335












COMP 335
*






COMP 335












COMP 335
*






COMP 335












COMP 335
*





Output: “reject”
Input finished

COMP 335












COMP 335
*
Formalities for DFA
Deterministic Finite Accepter/Automaton M:
: States (a finite set of states)
: Alphabet (a finite set of input symbols)
: Transition function (δ: QxΣ→Q)
: Initial state (an element of Q)
: Final states (a subset of Q)

COMP 335








COMP 335
*
Input Alphabet 
 









COMP 335



















COMP 335
*
Set of States 
 









COMP 335



















COMP 335
*
Initial State 
 









COMP 335


















COMP 335
*
 Final State(s)
 









COMP 335



















COMP 335
*
Transition Function 
 









COMP 335



















COMP 335
*
 









COMP 335


















COMP 335
*
 









COMP 335


















COMP 335
*









COMP 335


















COMP 335
*
Transition Function
 










COMP 335







































COMP 335
*
Extended Transition Function  
 









COMP 335
















COMP 335
*









COMP 335















COMP 335
*









COMP 335


















COMP 335
*









COMP 335


















COMP 335
*
 Observation:  There is a walk from      to    
                       with label    , then we write:








COMP 335















COMP 335
*







 Example:  There is a walk from        to    
                       with label


COMP 335





















COMP 335
*
Recursive Definition








COMP 335












COMP 335
*
 











COMP 335


















COMP 335
*
Languages Accepted by DFAs
Consider a DFA 

Definition:
The language             includes all strings
 (over the alphabet) accepted by 


           = { strings that drive       to a final state}   

COMP 335







COMP 335
*
Example
 








accept


COMP 335



















COMP 335
*
Another Example








accept


accept
accept
 


COMP 335



















COMP 335
*
Formally

Given a DFA

The language accepted by     :

 




COMP 335









COMP 335
*
Observation
 Also note that the language rejected by    :



COMP 335








COMP 335
*
More Examples
 




accept
trap state

COMP 335










COMP 335
*

 
= { all strings with prefix       }




accept


COMP 335














COMP 335
*
Design a DFA for the language:
 
L={w: w does not have the substring       }








COMP 335














COMP 335
*
Regular Languages

Definition: A language     is regular if there is 
a DFA        that accepts    , that is,                  .



All regular languages form a family.
 

COMP 335






COMP 335
*
 { all strings with prefix       }
{ all strings with suffix      }
{ all strings without substring        }
Examples of regular languages:
For each of these languages, there exists  
a DFA that accepts the language.

COMP 335








COMP 335
*
Another Example
To language that
is regular, we give a DFA M for L such that

 






COMP 335















COMP 335
*
There are languages that are not Regular.
Later on we will present a technique using 
which we can show that there is no DFA for
this languages. 
Example:

COMP 335


UNKNOWN-0.unknown

UNKNOWN-1.unknown

UNKNOWN-2.unknown

UNKNOWN-3.unknown

UNKNOWN-4.unknown

UNKNOWN-5.unknown

UNKNOWN-6.unknown

UNKNOWN-7.unknown

UNKNOWN-8.unknown

UNKNOWN-9.unknown

UNKNOWN-10.unknown

UNKNOWN-11.unknown

UNKNOWN-12.unknown

UNKNOWN-13.unknown

UNKNOWN-14.unknown

UNKNOWN-15.unknown

UNKNOWN-16.unknown

UNKNOWN-17.unknown

UNKNOWN-18.unknown

UNKNOWN-19.unknown

UNKNOWN-20.unknown

UNKNOWN-21.unknown

UNKNOWN-22.unknown

UNKNOWN-23.unknown

UNKNOWN-24.unknown

UNKNOWN-25.unknown

UNKNOWN-26.unknown

UNKNOWN-27.unknown

UNKNOWN-28.unknown

UNKNOWN-29.unknown

UNKNOWN-30.unknown

UNKNOWN-31.unknown

UNKNOWN-32.unknown

UNKNOWN-33.unknown

UNKNOWN-34.unknown

UNKNOWN-35.unknown

UNKNOWN-36.unknown











0
q









1
q









2
q









3
q









4
q









a









b









5
q









b
a
,









l









(
)
F
q
Q
M
,
,
,
,
0
d
S
=









Q









S









d









0
q









F









{
}
b
a
,
=
S









{
}
5
4
3
2
1
0
,
,
,
,
,
q
q
q
q
q
q
Q
=









{
}
4
q
F
=









Q
Q
®
S
´
:
d









(
)
1
0
,
q
a
q
=
d









(
)
5
0
,
q
b
q
=
d









(
)
3
2
,
q
b
q
=
d









d









5
q









*
d









Q
Q
®
S
´
*
:
*
d









(
)
2
0
,
*
q
ab
q
=
d









(
)
4
0
,
*
q
abba
q
=
d









(
)
5
0
,
*
q
abbbaa
q
=
d









(
)
q
w
q
¢
=
,
*
d









q









q
¢









w









q









k
w
s
s
s
L
2
1
=









1
s









2
s









k
s









0
q









abbbaa









(
)
(
)
)
),
,
(
*
(
,
*
,
*
s
d
d
s
d
l
d
w
q
w
q
q
q
=
=









s









1
q









(
)
q
q
q
w
q
¢
=
¢
=
)
,
(
,
*
1
s
d
s
d









(
)
(
)
1
1
,
*
)
,
(
,
*
q
w
q
q
w
q
=
=
d
s
d
s
d









(
)
)
),
,
(
*
(
,
*
s
d
d
s
d
w
q
w
q
=









(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
2
1
0
0
0
0
,
,
,
,
,
,
*
),
,
(
*
,
*
q
b
q
b
a
q
b
a
q
b
a
q
ab
q
=
=
=
=
=
d
d
d
l
d
d
d
d
d
d









M









(
)
M
L









M









(
)
{
}
abba
M
L
=









(
)
{
}
abba
ab
M
L
,
,
l
=









M









(
)
(
)
{
}
F
w
q
w
M
L
Î
S
Î
=
,
*
:
*
0
d









0
q









F
q
Î
¢









(
)
(
)
{
}
F
w
q
w
M
L
Ï
S
Î
=
,
*
:
*
0
d









F
q
Ï
¢









(
)
}
0
:
{
³
=
n
b
a
M
L
n









(
)
M
L









ab









l









0









00









001









1









1
,
0









L









(
)
M
L
L
=









{
}
abba









{
}
abba
ab
,
,
l









}
0
:
{
³
n
b
a
n









{
}
{
}
*
,
:
b
a
w
awa
L
Î
=









}
0
:
{
³
=
n
b
a
L
n
n
