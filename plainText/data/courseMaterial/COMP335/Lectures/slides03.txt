



















Languages and Finite Automata


COMP 335
*
- Non Deterministic Finite Automata (N)FA

- NFA to DFA Conversion Algorithm
*

COMP 335


COMP 335
*





Alphabet =
Non deterministic Finite Automata (NFA)

COMP 335










COMP 335
*





Two choices
Alphabet =
Nondeterministic Finite Accepter (NFA)

COMP 335










COMP 335
*
No transition





Two choices
No transition
Alphabet =
Non deterministic Finite Automata (NFA)

COMP 335










COMP 335
*






First Choice

COMP 335











COMP 335
*






First Choice

COMP 335











COMP 335
*






First Choice

COMP 335











COMP 335
*






“accept”
First Choice
All input is consumed

COMP 335











COMP 335
*






Second Choice

COMP 335











COMP 335
*






Second Choice

COMP 335











COMP 335
*






Second Choice
No transition:
the automaton “hangs”

COMP 335











COMP 335
*






Second Choice
“reject”
Input cannot be consumed

COMP 335











COMP 335
*
An NFA M accepts an input string w if

(1) there is at least one computation of M
     that accepts w
(3) M is in a final state
AND
AND
(2) all the symbols in w is consumed 

COMP 335


COMP 335
*
Example
is accepted by this NFA:
“accept”





“reject”
because through the 
marked computation
It accepts 










COMP 335











COMP 335
*






Rejection example

COMP 335










COMP 335
*






First Choice

COMP 335










COMP 335
*






First Choice
“reject”

COMP 335










COMP 335
*
Second Choice







COMP 335










COMP 335
*
Second Choice







COMP 335










COMP 335
*
Second Choice






“reject”

COMP 335










COMP 335
*
An NFA rejects a string w:
if there is no computation of the NFA
that accepts the string w: 
	 All the input is consumed and the 

  automaton is in a non final state
	 The input cannot be consumed

OR

COMP 335


COMP 335
*
Example
The input    is rejected by the NFA since:





“reject”





“reject”
all possible computations lead to rejection

COMP 335

















COMP 335
*
Rejection example







COMP 335












COMP 335
*






First Choice

COMP 335












COMP 335
*






First Choice
No transition:
the automaton hangs

COMP 335












COMP 335
*






“reject”
First Choice
Input cannot be consumed

COMP 335












COMP 335
*






Second Choice

COMP 335












COMP 335
*






Second Choice

COMP 335












COMP 335
*






Second Choice
No transition:
the automaton hangs

COMP 335












COMP 335
*






Second Choice
“reject”
Input cannot be consumed

COMP 335












COMP 335
*
is rejected by the NFA:
“reject”





“reject”
All possible computations lead to rejection










COMP 335










COMP 335
*





The language accepted is

COMP 335










COMP 335
*
Lambda Transitions






COMP 335









COMP 335
*







COMP 335











COMP 335
*







COMP 335











COMP 335
*






(read head does not move)

COMP 335











COMP 335
*







COMP 335











COMP 335
*






“accept”
String        is accepted
all input is consumed

COMP 335












COMP 335
*






Rejection Example

COMP 335












COMP 335
*







COMP 335












COMP 335
*






(read head doesn’t move)

COMP 335












COMP 335
*






No transition:
the automaton hangs

COMP 335












COMP 335
*






“reject”
String           is rejected
Input cannot be consumed

COMP 335













COMP 335
*
Language accepted:






COMP 335










COMP 335
*
Another NFA Example






COMP 335










COMP 335
*







COMP 335












COMP 335
*







COMP 335












COMP 335
*







COMP 335












COMP 335
*






“accept”

COMP 335












COMP 335
*






Another String

COMP 335














COMP 335
*







COMP 335














COMP 335
*







COMP 335














COMP 335
*







COMP 335














COMP 335
*







COMP 335














COMP 335
*







COMP 335














COMP 335
*







COMP 335














COMP 335
*






“accept”

COMP 335














COMP 335
*
Language accepted






COMP 335











COMP 335
*
Another example NFA






COMP 335









COMP 335
*




Language accepted by M
(redundant
 state)

COMP 335










COMP 335
*
Remarks:
	The symbol    never appears on the 

 input tape 



	Examples of some simple automata:


COMP 335









COMP 335
*







NFA
DFA
	NFAs are interesting because using them 

 we can express languages easier than DFAs

COMP 335















COMP 335
*
Formal Definition of NFAs
 
Set of states,  i.e.,
Input aphabet, i.e.,
Transition function
Initial state
Final state(s)

COMP 335










COMP 335
*




Transition Function 

COMP 335











COMP 335
*





COMP 335










COMP 335
*





COMP 335










COMP 335
*





COMP 335










COMP 335
*
Extended Transition Function 
  









COMP 335
















COMP 335
*









COMP 335















COMP 335
*









COMP 335















COMP 335
*
Formally

: there is a walk from      to
  with label  








COMP 335















COMP 335
*
The Language of an NFA
 









COMP 335





















COMP 335
*
 









COMP 335




















COMP 335
*

 









COMP 335




















COMP 335
*
 









COMP 335




















COMP 335
*

  









COMP 335

















COMP 335
*
Formally
The language accepted by NFA      is:




where


and there is some 
(final state)

COMP 335






COMP 335
*

 







COMP 335












COMP 335
*
NFA accept Regular Languages
 

COMP 335


COMP 335
*
Equivalent FA’s

Definition:

An FA         is equivalent to FA

if 

that is, if both accept the same language.

COMP 335





COMP 335
*
Example of equivalent FA’s
  







NFA
DFA

COMP 335


















COMP 335
*
We will prove:
Languages 
accepted
by NFA
Regular
Languages




That is, NFA and DFA have 
the same computing power
Languages 
accepted
by DFA

COMP 335



COMP 335
*
Languages 
accepted
by NFA
Regular
Languages




Step 1
Proof:
Every DFA is trivially an NFA
Any language      accepted by a DFA
is also accepted by an NFA


COMP 335




COMP 335
*
Languages 
accepted
by NFA
Regular
Languages




Step 2
Proof:
Any NFA can be converted into an
equivalent DFA
Any language accepted by an NFA
is also accepted by a DFA


COMP 335



COMP 335
*
Converting NFA to DFA
  




NFA
DFA


COMP 335












COMP 335
*
Converting NFA to DFA
 




NFA
DFA



COMP 335














COMP 335
*
Converting NFA to DFA
  




NFA
DFA




COMP 335
















COMP 335
*
Converting NFA to DFA
 




NFA
DFA




COMP 335

















COMP 335
*
Converting NFA to DFA
  




NFA
DFA




COMP 335


















COMP 335
*
Converting NFA to DFA
  




NFA
DFA




COMP 335



















COMP 335
*
Converting NFA to DFA
 




NFA
DFA





COMP 335




















COMP 335
*
Details on NFA to DFA Conversion

Given any NFA     ,

We want to convert it 
into an equivalent DFA


That is,

COMP 335





COMP 335
*
If the given NFA has the states:

                  Q= {                   }

then the resulting DFA has the states with labels in the powerset of Q:
 

COMP 335




COMP 335
*
NFA to DFA Conversion Algorithm
 

1.  Initial state of NFA:

     

      Initial state of DFA:     


COMP 335




COMP 335
*
Example
 




NFA
DFA


COMP 335












COMP 335
*
NFA to DFA Conversion Algorithm
  2. For every state                         in the  DFA and every symbol a in the alphabet, determine the following from the NFA:


        

    and add the following transition to the 
   DFA


COMP 335







COMP 335
*
Example
 




NFA


DFA

COMP 335
















COMP 335
*
NFA to DFA Conversion Algorithm


Repeat step 2 of the NFA-to-DFA
conversion algorithm for every symbol “a” 
in the alphabet, until no more transitions 
can be added to the DFA.

COMP 335


COMP 335
*
Example
 




NFA
DFA




COMP 335



















COMP 335
*
NFA to DFA Conversion Algorithm
 
 3. For each state                        in the DFA

        if some       is a final state in the NFA,
        then mark                         as a final
        state in the DFA
                      

COMP 335





COMP 335
*
NFA to DFA Conversion Algorithm
  4. If the input NFA accepts the 
       empty string        
       
       then mark         in the DFA as a
       final state as well.
        
                      

COMP 335




COMP 335
*
Example
 




NFA
DFA





COMP 335





















COMP 335
*
Theorem
   
Given any NFA     , 
the conversion algorithm yields a DFA 
that is equivalent to     , that is,

COMP 335






COMP 335
*
Proof

AND

COMP 335





COMP 335
*
First we show:
Take arbitrary string :
We will prove:

COMP 335





COMP 335
*











COMP 335














COMP 335
*












We will show that if 


COMP 335

















COMP 335
*










More generally, we will show that if in     :
(arbitrary string)


COMP 335






















COMP 335
*




Proof by induction on 
The basis case:

COMP 335












COMP 335
*
Induction hypothesis:











COMP 335






















COMP 335
*
Induction Step:













COMP 335
























COMP 335
*
Induction Step:















COMP 335




























COMP 335
*












Therefore if 


COMP 335

















COMP 335
*
We have shown:
We also need to show:
(proof is similar)

COMP 335



UNKNOWN-0.unknown

UNKNOWN-1.unknown

UNKNOWN-2.unknown

UNKNOWN-3.unknown

UNKNOWN-4.unknown

UNKNOWN-5.unknown

UNKNOWN-6.unknown

UNKNOWN-7.unknown

UNKNOWN-8.unknown

UNKNOWN-9.unknown

UNKNOWN-10.unknown

UNKNOWN-11.unknown

UNKNOWN-12.unknown

UNKNOWN-13.unknown











1
q









2
q









3
q









a









0
q









}
{
a









aa









a









aaa









}
{
aa
L
=









3
q









l









2
q









2
q









aa









0
q









1
q









a









b









a









b









1
q









2
q









1
q









2
q









{
}
{
}
+
=
=
ab
ababab
abab
ab
L
...
,
,
,









0
q









2
q









0









1









1
,
0









{
}
{
}
*
10
=
...
,
101010
,
1010
,
10
,
λ
=
)
(
M
L









2
M









1
M









{}
=
)
M
(
L
1









}
λ
{
=
)
M
(
L
2









0
q









2
q









1
q









a









}
{
=
)
(
1
a
M
L









}
{
=
)
(
2
a
M
L









(
)
F
q
Q
M
,
,
,
,
0
d
S
=









:
Q









:
d









:
0
q









:
F









{
}
2
1
0
,
,
q
q
q









:
S









{
}
b
a
,









(
)
{
}
1
0
1
,
q
q
=
d









1
q









2
q









d









}
,
{
)
0
,
(
2
0
1
q
q
q
=
d









}
,
{
)
,
(
2
0
0
q
q
q
=
l
d









Æ
=
)
1
,
(
2
q
d









*
d









l









5
q









4
q









3
q









b









(
)
{
}
1
0
,
*
q
a
q
=
d









(
)
{
}
5
4
0
,
,
*
q
q
aa
q
=
d









(
)
{
}
0
3
2
0
,
,
,
*
q
q
q
ab
q
=
d









(
)
w
q
q
i
j
,
*
d
Î









i
q









j
q









w









i
q









j
q









w









k
w
s
s
s
L
2
1
=









1
s









2
s









k
s









(
)
{
}
5
4
0
,
,
*
q
q
aa
q
=
d









M









)
(
M
L
aa
Î









{
}
5
0
,
q
q
F
=









F
Î









(
)
{
}
0
3
2
0
,
,
,
*
q
q
q
ab
q
=
d









(
)
M
L
ab
Î









(
)
{
}
5
4
0
,
,
*
q
q
abaa
q
=
d









)
(
M
L
abaa
Î









(
)
{
}
1
0
,
*
q
aba
q
=
d









(
)
M
L
aba
Ï









F
Ï









(
)
{
}
}
{
*
}
{
*
aa
ab
ab
M
L
È
=









M









(
)
{
}
,...
,
,
3
2
1
w
w
w
M
L
=









}
,
,...,
,
{
)
,
(
*
0
K
k
j
i
m
q
q
q
w
q
=
d









F
q
k
Î









k
q









w









)
,
(
*
0
w
q
d









(
)
M
L
w
Î









F
q
k
Î









i
q









j
q









1
M









2
M









(
)
(
)
2
1
M
L
M
L
=









1
q









0









1









2
q









1









0









1
,
0









(
)
*
}
10
{
1
=
M
L









(
)
*
}
10
{
2
=
M
L









1
M









2
M









=









Ê









L









Í









{
}
0
q









M









M
¢









{
}
2
1
,
q
q









Æ









b
a
,









(
)
)
(
M
L
M
L
¢
=









,...
,
,
2
1
0
q
q
q









{
}
{
}
{
}
,....
,
,
,
,
2
1
1
0
q
q
q
q
Æ









0
q









{
}
0
q









}
,...,
,
{
m
j
i
q
q
q









(
)
(
)
...
,
*
,
*
a
q
a
q
j
i
d
d









}
,...,
,
{
m
j
i
q
q
q
¢
¢
¢









(
)
}
,...,
,
{
},
,...,
,
{
m
j
i
m
j
i
q
q
q
a
q
q
q
¢
¢
¢
=
d









=









}
,
{
)
,
(
*
2
1
0
q
q
a
q
=
d









{
}
(
)
{
}
2
1
0
,
,
q
q
a
q
=
d









}
,...,
,
{
m
j
i
q
q
q









j
q









F
q
Î
1









{
}
F
q
q
¢
Î
2
1
,









M









M
¢









(
)
(
)
M
L
M
L
¢
=









(
)
(
)
M
L
M
L
¢
Í









(
)
(
)
M
L
M
L
¢
Ê









)
(
M
L
w
Î









)
(
M
L
w
¢
Î









0
q









f
q









:
M









}
{
0
q









:
M
¢









}
,
{
K
f
q









)
(
M
L
w
¢
Î









m
q









n
a
a
a
v
L
2
1
=









1
a









2
a









n
a









n
a









}
,
{
K
i
q









l
q









}
,
{
K
j
q









}
,
{
K
l
q









}
,
{
K
m
q









M









1
a
v
=









|
|
v









k
v
£
£
|
|
1









d
q









k
a









c
q









}
,
{
K
c
q









}
,
{
K
d
q









k
a
a
a
v
L
2
1
=









1
|
|
+
=
k
v









k
a









1
1
2
1
+
+
¢
¢
=
=
k
k
v
k
a
v
a
a
a
a
v
4
3
4
2
1
L









v
¢









v
¢









1
1
2
1
+
+
¢
¢
=
=
k
k
v
k
a
v
a
a
a
a
v
4
3
4
2
1
L









e
q









1
+
k
a









1
+
k
a









}
,
{
K
e
q









(
)
(
)
M
L
M
L
¢
Ê
